import os
import sys
import copy
import numpy as np
from classes import *
from ele_tests import *

"""
A helper for the elementwise backpropagations.
"""

def extract_indices(indices, start_index = 0, stepsize = 1, length = 2):
    """
    extract_indices(indices, start_index = 0, stepsize = 1, length = 2)
    returns all indices in indices, that are not contained in the series generated by start_index and step_size.
    """
    samples = np.arange(start_index, length, stepsize).astype('int')
    return np.setdiff1d(indices, samples)

"""
After a successfull termination of bfs one has the result for a specific layer.
The Information of the deeper layers needs to be backpropagated upwards, thus the following routines.
"""

def backprop_dif(ancestor, child):
    """
    backprop_dif(ancestor, child)
    Input: 
     ancestor -> data type object
     child -> data type object
    Output:
     None
    Given an ancestor and a child generated by elementwise differences;
    This method fills the positions in ancestor.series which are now known.
    """
    series    = ancestor.series
    values    = child.series
    positions = (np.squeeze(np.nonzero(np.isnan(series)))) #the positions which contain np.nan
    if positions.ndim >= 1:
        for index in positions: #Moving forwards through the positions, filling all which have a number 'below' them
            if index >= 1:
                series[index] = series[index-1]+values[index-1]
        for index in np.flip(positions): #Moving backwards, filling all positions which have a number 'above' them
            if index <= series.size - 2:
                series[index] = series[index+1]-values[index]
    else:
        if positions >= 1:
            series[positions]   = series[positions-1] + values[positions-1]
        else: series[positions] = series[positions+1] - values[positions]
    ancestor.series = series
    pass

def backprop_quo(ancestor, child):
    """
    backprop_quo(ancestor, child)
    Input: 
     ancestor -> data type object
     child -> data type object
    Output:
     None
    Given an ancestor and a child generated by elementwise quotients;
    This method fills the positions in ancestor.series which are now known.
    """
    series    = ancestor.series
    values    = child.series
    positions = (np.squeeze(np.nonzero(np.isnan(series)))) #the positions which contain np.nan
    if positions.ndim >= 1:
        for index in positions: #Moving forwards through the positions, filling all which have a number 'below' them
            if index >= 1:
                series[index] = series[index-1] * values[index-1]
        for index in np.flip(positions): #Moving backwards, filling all positions which have a number 'above' them
            if index <= series.size - 2:
                if values[index] != 0.:
                    series[index] = series[index+1] / values[index]
    else:
        if positions >= 1:
            series[positions]   = series[positions-1] * values[positions-1]
        else: series[positions] = series[positions+1] / values[positions]
    ancestor.series = series
    pass

def backprop_square(ancestor, mode = 'pos'):
    """
    backprop_square(ancestor, mode = 'pos')
    Input: 
     ancestor -> data type object
     mode -> indicator of sign
    Output:
     None
    Given an ancestor;
    This method fills the positions in ancestor.series which are squares with the respective square.
    """
    series    = ancestor.series
    positions = np.arange(0,series.size) #the positions which are not prooven to be squares
    if mode == 'pos':
        positive_indices = [i for i, e in enumerate(ancestor.positive_tests) if (e[0] == 'square' and e[3] == '+')]
        for element in ancestor.positive_tests[positive_indices]:
            positions = extract_indices(positions, start_index = element[1], stepsize = element[2], length = series.size)
        indices = np.setdiff1d(np.arange(0,series.size),positions) #the positions which contain squares
        ancestor.series[indices] = series[indices]**2
    else:
        positive_indices = [i for i, e in enumerate(ancestor.positive_tests) if (e[0] == 'square' and e[3] == '-')]
        for element in ancestor.positive_tests[positive_indices]:
            positions = extract_indices(positions, start_index = element[1], stepsize = element[2], length = series.size)
        indices = np.setdiff1d(np.arange(0,series.size),positions) #the positions which contain squares
        ancestor.series[indices] = -series[indices]**2
    pass

def backprop_cube(ancestor, mode = 'pos'):
    """
    backprop_cube(ancestor, mode = 'pos')
    Input: 
     ancestor -> data type object
     mode -> indicator of sign
    Output:
     None
    Given an ancestor;
    This method fills the positions in ancestor.series which are cubes with the respective cube.
    """
    series    = ancestor.series
    positions = np.arange(0,series.size) #the positions which are not prooven to be cubes
    if mode == 'pos':
        positive_indices = [i for i, e in enumerate(ancestor.positive_tests) if (e[0] == 'cube' and e[3] == '+')]
        for element in ancestor.positive_tests[positive_indices]:
            positions = extract_indices(positions, start_index = element[1], stepsize = element[2], length = series.size)
        indices = np.setdiff1d(np.arange(0,series.size),positions) #the positions which contain cubes
        ancestor.series[indices] = series[indices]**3
    else:
        positive_indices = [i for i, e in enumerate(ancestor.positive_tests) if (e[0] == 'cube' and e[3] == '-')]
        for element in ancestor.positive_tests[positive_indices]:
            positions = extract_indices(positions, start_index = element[1], stepsize = element[2], length = series.size)
        indices = np.setdiff1d(np.arange(0,series.size),positions) #the positions which contain cubes
        ancestor.series[indices] = -series[indices]**3
    pass

def backprop_prime(ancestor, mode = 'pos'):
    """
    backprop_prime(ancestor, mode = 'pos')
    Input: 
     ancestor -> data type object
     mode -> indicator of sign
    Output:
     None
    Given an ancestor;
    This method fills the positions in ancestor.series which are prime with the respective prime.
    """
    series    = ancestor.series
    positions = np.arange(0,series.size) #the positions which are not prooven to be prime
    if mode == 'pos':
        positive_indices = [i for i, e in enumerate(ancestor.positive_tests) if (e[0] == 'prime' and e[3] == '+')]
        for element in ancestor.positive_tests[positive_indices]:
            positions = extract_indices(positions, start_index = element[1], stepsize = element[2], length = series.size)
        indices = np.setdiff1d(np.arange(0,series.size),positions) #the positions which contain primes
        ancestor.series[indices] = get_prime(series[indices])
    else:
        positive_indices = [i for i, e in enumerate(ancestor.positive_tests) if (e[0] == 'prime' and e[3] == '-')]
        for element in ancestor.positive_tests[positive_indices]:
            positions = extract_indices(positions, start_index = element[1], stepsize = element[2], length = series.size)
        indices = np.setdiff1d(np.arange(0,series.size),positions) #the positions which contain primes
        ancestor.series[indices] = -get_prime(series[indices])
    pass

def get_prime(np_array):
    """
    get_prime(np_array)
    Input:
     np_array -> a numpy array
    Output:
     The corresponding primenumbers to the positions specified.
    """
    if np_array.size >= 2:
        max_used     = np_array.max # The maximal Prime needed.
    else:
        max_used = np_array
    primenumbers = gen_prime(max_used) # Generate all primes up to the maximum, then all needed primes are given
    return primenumbers[np_array] # Retrun the positions which are needed.

def gen_prime(number):
    """
    gen_prime(number)
    Input:
     number -> a natural number (positive int)
    Output:
     A sorted superset of the first n = number primenumbers, containing only primes.
    
    Using the Prime number theorem assumed by Gau√ü, check each interval for primenumbers.
    Append these Primes to the set of already found prime numbers.
    """
    counter      = 0
    exponent     = 0.
    primenumbers = np.asarray([])
    while counter <= number-1:
        operating_range = np.arange(10**(exponent),10**(exponent+1)) #[1;10),[10;100),[100;1000),...
        primes          = is_prime(operating_range)
        counter        += primes.sum()
        primenumbers    = np.concatenate((primenumbers, primes))
        exponent       += 1
    return primenumbers


def find_root_of_family_tree(child):
    """
    find_root_of_family_tree(child):
    Input:
     child -> data type object
    Output:
     root of the family tree -> data type object
    This method follows the family tree of a given object to its root.
    The ancestors on the way get completed (np.nans get exchanged for numbers based on the child)
    """
    for ancestor in child.ancestors:
        if ancestor != None:
            if 'square' in ancestor.positive_tests:
                if '+' in ancestor.positive_tests:
                    backprop_square(ancestor, mode = 'pos')
                else:
                    backprop_square(ancestor, mode = 'neg')
            elif 'cube' in ancestor.positive_tests:
                if '+' in ancestor.positive_tests:
                    backprop_cube(ancestor, mode = 'pos')
                else:
                    backprop_cube(ancestor, mode = 'neg')
            elif 'prime' in ancestor.positive_tests:
                if '+' in ancestor.positive_tests:
                    backprop_prime(ancestor, mode = 'pos')
                else:
                    backprop_prime(ancestor, mode = 'neg')
            elif child.gender == 'dif':
                backprop_dif(ancestor, child)
            elif child.gender == 'quo':
                backprop_quo(ancestor, child)
            else:
                print("ERROR: This relation between child and ancestor is not known!")
                pass
            child = find_root_of_family_tree(ancestor)
        else:
            return child
    return child

def return_solutions(output_bfs):
    """
    return_solutions(output_bfs):
    Input:
     output_bfs -> output of bfs or other search
     this is an array which contains data type objects
    Output:
     all possible soloutions found by the search
    """
    result = np.asarray([])
    if output_bfs.size>=1:
        for child in output_bfs:
            result = np.append(result, find_root_of_family_tree(child))
        return result
    return 0